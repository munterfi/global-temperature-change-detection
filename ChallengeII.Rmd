---
title: 'Challenge II: Spatial continuity and weather prediction'
author:
- "Olivier Niklaus, Geography UZH"
- "Merlin Unterfinger, Geography UZH"
date: 25 6 2017
output:
  rmarkdown::pdf_document:
    fig_caption: yes        
    includes:  
      in_header: preamble-latex.tex
    number_sections: yes
    toc: yes
    toc_depth: 3
#    citation_package: natbib
  html_document: default
#biblio-style: "apalike"
#link-citations: true
#csl: apa.csl
#bibliography: References.bib
#abstract: "blablabalbalbalbalbalbalbalbalbalaalbalbla"
filter: pandoc-eqnos
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

rm(list=ls())             # Clean the environment
options(scipen=6)         # Display digits, not the scientific version
options(digits.secs=6)    # use milliseconds in Date/Time data types
options(warning=FALSE)    # Don't show warnings
par(mfrow=c(1,1))         # reset plot placement to normal 1 by 1

dataFolder    <- file.path(getwd(), "data")            # Data folder
figureFolder  <- file.path(getwd(), "figures")         # Figure Folder
```

\newpage

# Libraries
The following libraries are needed, to execute the code:

* **ggplot2** -- Plots -- [@ggplot2]
* **plyr** -- Splitting, applying and combining data -- [@plyr]
* **rgdal** -- Open Shapefiles -- [@rgdal]
* **sp** -- Spatial datatypes -- [@sp2; @sp1]
* **gstat** -- Spatial statistics --[@gstat]
* **FNN** -- Spatial statistics --[@FNN]


```{r Libraries, message=FALSE, echo=FALSE}
#library(e1071)            # Support Vector Machine library
library(sp)               # Spatial data types
library(rgeos)            # Geoprocessing
library(rgdal)            # Open Shapefiles
library(ggplot2)          # Plots
library(gdistance)        # Least cost path - Walking time
library(rasterVis)        # Plots of rasters
library(plyr)
#spatial statistics library
#install.packages("gstat")
library(gstat)
#install.packages("FNN")
library(FNN)
#install.packages("spdep")
library(spdep)
library(gridExtra)
library(raster)

```

# Data
```{r Geodata, message=FALSE, warning=FALSE , echo=FALSE, fig.height=3, fig.align="center"}
# Define CRS
WGS84 <- CRS("+init=epsg:4326")

# Read CSV file for temperature
temp <- read.csv(file.path(dataFolder, "temperature.csv"))
temp <- temp[complete.cases(temp), ]
coordinates(temp)<-~long+lat
proj4string(temp)<-WGS84

# Read test file
temp.test <- read.csv(file.path(dataFolder, "temperature_test.csv"))
coordinates(temp.test) <- ~long+lat
proj4string(temp.test) <- WGS84

plot(temp)
points(temp.test, col="red")
knitr::kable(head(round(as.data.frame(head(temp)),2), caption = "Structure of the temperature data set.", row.names = FALSE))

# Seperate data according to timeFrame and season
temp1970w <-SpatialPointsDataFrame(coords = temp@coords, data = temp@data[,1:2])
temp1970s <-SpatialPointsDataFrame(coords = temp@coords, data = temp@data[,c(1,3)])
temp2010w <-SpatialPointsDataFrame(coords = temp@coords, data = temp@data[,c(1,4)])
temp2010s <-SpatialPointsDataFrame(coords = temp@coords, data = temp@data[,c(1,5)])

col <- c("id", "meansum")
colnames(temp1970s@data) <- col
colnames(temp2010s@data) <- col
colnames(temp1970w@data) <- col
colnames(temp2010w@data) <- col

# Open digital elevation model
DEM <-readGDAL(file.path(dataFolder, "globalDHM.tif"), silent = T)
#plot(DEM, col=topo.colors(20))
landDEM <- raster(DEM)
landDEM[landDEM<0] <- 0

# Set up grid, for prediction
grid <- spsample(DEM,type="regular",10000)
grid <- SpatialPointsDataFrame(grid@coords,data.frame(elevation=extract(raster(DEM),grid)))

# Load coastlines for plotting
oceans <- readOGR(dsn="data", "ne_110m_ocean", verbose=F)

levelplot(landDEM) + layer(sp.polygons(oceans, fill='lightblue', alpha=0.3))
```

\newpage
# Spatial continuity
## First impressions of spatial variation
### Winter before 1970
```{r temp1970w, eval=TRUE, echo=FALSE, fig.height=3, fig.align="center", fig.cap="Mean temperature Winter from 1950 to 1970"}

#plotting the coefficients of variation for all varibles
spplot(temp1970w, "meansum", colorkey=T)
```

### Summer before 1970
```{r temp1970s, eval=TRUE, echo=FALSE, fig.height=3, fig.align="center", fig.cap="Mean temperature Winter from 1950 to 1970"}

#plotting the coefficients of variation for all varibles
spplot(temp1970s,"meansum", colorkey=T)
```
### Winter after 1990
```{r temp2010w, eval=TRUE, echo=FALSE, fig.height=3, fig.align="center", fig.cap="Mean temperature Winter from 1990 to 2010"}

#plotting the coefficients of variation for all varibles
spplot(temp2010w,"meansum", colorkey=T)
```
### Summer after 1990
```{r temp2010s, eval=TRUE, echo=FALSE, fig.height=3, fig.align="center", fig.cap="Mean temperature Winter from 1990 to 2010"}

#plotting the coefficients of variation for all varibles
spplot(temp2010s,"meansum", colorkey=T)
```
## H - Scatterplots and autocovariance plots
### Summer before 1970
```{r scatter, echo=FALSE, fig.align="center", fig.height=4}

temp.dist<-spDists(temp1970s,longlat = FALSE)
temp.index <-knn.index(temp.dist, k=20, algorithm=c("kd_tree"))

temp.h<-data.frame(sum=temp1970s$meansum ,sumNN1=temp1970s$meansum[temp.index[,1]],sumNN5=temp1970s$meansum[temp.index[,5]],sumNN10=temp1970s$meansum[temp.index[,10]],sumNN20=temp1970s$meansum[temp.index[,20]])

par(mfrow=c(2,2))
plot(temp.h$sum,temp.h$sumNN1,main="h = 1")
abline(1,1, col = "blue")
plot(temp.h$sum,temp.h$sumNN5,main="h = 5")
abline(1,1, col = "blue")
plot(temp.h$sum,temp.h$sumNN10,main="h = 10")
abline(1,1, col = "blue")
plot(temp.h$sum,temp.h$sumNN20,main="h = 20")
abline(1,1, col = "blue")

##Autocovariance plots
temp.mean <- mean(temp.h$sum, na.rm = TRUE)
temp.sd<-sd(temp.h$sum, na.rm = TRUE)

temp.acov.nn1<-sum((temp.h$sum-temp.mean)*(temp.h$sumNN1-temp.mean), na.rm = TRUE)/nrow(temp.h)
temp.acov.nn5<-sum((temp.h$sum-temp.mean)*(temp.h$sumNN5-temp.mean), na.rm = TRUE)/nrow(temp.h)
temp.acov.nn10<-sum((temp.h$sum-temp.mean)*(temp.h$sumNN10-temp.mean), na.rm = TRUE)/nrow(temp.h)
temp.acov.nn20<-sum((temp.h$sum-temp.mean)*(temp.h$sumNN20-temp.mean), na.rm = TRUE)/nrow(temp.h)

temp.acorr.nn1<-temp.acov.nn1/temp.sd^2
temp.acorr.nn5<-temp.acov.nn5/temp.sd^2
temp.acorr.nn10<-temp.acov.nn10/temp.sd^2
temp.acorr.nn20<-temp.acov.nn20/temp.sd^2

par(mfrow=c(1,2))
plot(c(1,5,10,20),c(temp.acov.nn1,temp.acov.nn5,temp.acov.nn10,temp.acov.nn20),type="l",main="auto-covariance")
plot(c(1,5,10,20),c(temp.acorr.nn1,temp.acorr.nn5,temp.acorr.nn10,temp.acorr.nn20),type="l",main="auto-correlation")

```
### Winter before 1970
```{r scatter2, echo=FALSE, fig.align="center", fig.height=4}

temp.dist<-spDists(temp1970w,longlat = FALSE)
temp.index <-knn.index(temp.dist, k=20, algorithm=c("kd_tree"))

temp.h<-data.frame(sum=temp1970w$meansum ,sumNN1=temp1970w$meansum[temp.index[,1]],sumNN5=temp1970w$meansum[temp.index[,5]],sumNN10=temp1970w$meansum[temp.index[,10]],sumNN20=temp1970w$meansum[temp.index[,20]])

par(mfrow=c(2,2))
plot(temp.h$sum,temp.h$sumNN1,main="h = 1")
abline(1,1, col = "blue")
plot(temp.h$sum,temp.h$sumNN5,main="h = 5")
abline(1,1, col = "blue")
plot(temp.h$sum,temp.h$sumNN10,main="h = 10")
abline(1,1, col = "blue")
plot(temp.h$sum,temp.h$sumNN20,main="h = 20")
abline(1,1, col = "blue")

##Autocoavariance plots
temp.mean<-mean(temp.h$sum, na.rm = TRUE)
temp.sd<-sd(temp.h$sum, na.rm = TRUE)

temp.acov.nn1<-sum((temp.h$sum-temp.mean)*(temp.h$sumNN1-temp.mean), na.rm = TRUE)/nrow(temp.h)
temp.acov.nn5<-sum((temp.h$sum-temp.mean)*(temp.h$sumNN5-temp.mean), na.rm = TRUE)/nrow(temp.h)
temp.acov.nn10<-sum((temp.h$sum-temp.mean)*(temp.h$sumNN10-temp.mean), na.rm = TRUE)/nrow(temp.h)
temp.acov.nn20<-sum((temp.h$sum-temp.mean)*(temp.h$sumNN20-temp.mean), na.rm = TRUE)/nrow(temp.h)

temp.acorr.nn1<-temp.acov.nn1/temp.sd^2
temp.acorr.nn5<-temp.acov.nn5/temp.sd^2
temp.acorr.nn10<-temp.acov.nn10/temp.sd^2
temp.acorr.nn20<-temp.acov.nn20/temp.sd^2

par(mfrow=c(1,2))
plot(c(1,5,10,20),c(temp.acov.nn1,temp.acov.nn5,temp.acov.nn10,temp.acov.nn20),type="l",main="auto-covariance")
plot(c(1,5,10,20),c(temp.acorr.nn1,temp.acorr.nn5,temp.acorr.nn10,temp.acorr.nn20),type="l",main="auto-correlation")

```
### Winter after 1990
```{r scatter3, echo=FALSE, fig.align="center", fig.height=4}

temp.dist<-spDists(temp2010w,longlat = FALSE)
temp.index <-knn.index(temp.dist, k=20, algorithm=c("kd_tree"))

temp.h<-data.frame(sum=temp2010w$meansum ,sumNN1=temp2010w$meansum[temp.index[,1]],sumNN5=temp2010w$meansum[temp.index[,5]],sumNN10=temp2010w$meansum[temp.index[,10]],sumNN20=temp2010w$meansum[temp.index[,20]])

par(mfrow=c(2,2))
plot(temp.h$sum,temp.h$sumNN1,main="h = 1")
abline(1,1, col = "blue")
plot(temp.h$sum,temp.h$sumNN5,main="h = 5")
abline(1,1, col = "blue")
plot(temp.h$sum,temp.h$sumNN10,main="h = 10")
abline(1,1, col = "blue")
plot(temp.h$sum,temp.h$sumNN20,main="h = 20")
abline(1,1, col = "blue")

##Autocoavariance plots
temp.mean<-mean(temp.h$sum, na.rm = TRUE)
temp.sd<-sd(temp.h$sum, na.rm = TRUE)

temp.acov.nn1<-sum((temp.h$sum-temp.mean)*(temp.h$sumNN1-temp.mean), na.rm = TRUE)/nrow(temp.h)
temp.acov.nn5<-sum((temp.h$sum-temp.mean)*(temp.h$sumNN5-temp.mean), na.rm = TRUE)/nrow(temp.h)
temp.acov.nn10<-sum((temp.h$sum-temp.mean)*(temp.h$sumNN10-temp.mean), na.rm = TRUE)/nrow(temp.h)
temp.acov.nn20<-sum((temp.h$sum-temp.mean)*(temp.h$sumNN20-temp.mean), na.rm = TRUE)/nrow(temp.h)

temp.acorr.nn1<-temp.acov.nn1/temp.sd^2
temp.acorr.nn5<-temp.acov.nn5/temp.sd^2
temp.acorr.nn10<-temp.acov.nn10/temp.sd^2
temp.acorr.nn20<-temp.acov.nn20/temp.sd^2

par(mfrow=c(1,2))
plot(c(1,5,10,20),c(temp.acov.nn1,temp.acov.nn5,temp.acov.nn10,temp.acov.nn20),type="l",main="auto-covariance")
plot(c(1,5,10,20),c(temp.acorr.nn1,temp.acorr.nn5,temp.acorr.nn10,temp.acorr.nn20),type="l",main="auto-correlation")
```
### Summer after 1990
```{r scatter4, echo=FALSE, fig.align="center", fig.height=4}

temp.dist<-spDists(temp2010s,longlat = FALSE)
temp.index <-knn.index(temp.dist, k=20, algorithm=c("kd_tree"))

temp.h<-data.frame(sum=temp2010s$meansum ,sumNN1=temp2010s$meansum[temp.index[,1]],sumNN5=temp2010s$meansum[temp.index[,5]],sumNN10=temp2010s$meansum[temp.index[,10]],sumNN20=temp2010s$meansum[temp.index[,20]])

par(mfrow=c(2,2))
plot(temp.h$sum,temp.h$sumNN1,main="h = 1")
abline(1,1, col = "blue")
plot(temp.h$sum,temp.h$sumNN5,main="h = 5")
abline(1,1, col = "blue")
plot(temp.h$sum,temp.h$sumNN10,main="h = 10")
abline(1,1, col = "blue")
plot(temp.h$sum,temp.h$sumNN20,main="h = 20")
abline(1,1, col = "blue")

##Autocoavariance plots
temp.mean<-mean(temp.h$sum, na.rm = TRUE)
temp.sd<-sd(temp.h$sum, na.rm = TRUE)

temp.acov.nn1<-sum((temp.h$sum-temp.mean)*(temp.h$sumNN1-temp.mean), na.rm = TRUE)/nrow(temp.h)
temp.acov.nn5<-sum((temp.h$sum-temp.mean)*(temp.h$sumNN5-temp.mean), na.rm = TRUE)/nrow(temp.h)
temp.acov.nn10<-sum((temp.h$sum-temp.mean)*(temp.h$sumNN10-temp.mean), na.rm = TRUE)/nrow(temp.h)
temp.acov.nn20<-sum((temp.h$sum-temp.mean)*(temp.h$sumNN20-temp.mean), na.rm = TRUE)/nrow(temp.h)

temp.acorr.nn1<-temp.acov.nn1/temp.sd^2
temp.acorr.nn5<-temp.acov.nn5/temp.sd^2
temp.acorr.nn10<-temp.acov.nn10/temp.sd^2
temp.acorr.nn20<-temp.acov.nn20/temp.sd^2

par(mfrow=c(1,2))
plot(c(1,5,10,20),c(temp.acov.nn1,temp.acov.nn5,temp.acov.nn10,temp.acov.nn20),type="l",main="auto-covariance")
plot(c(1,5,10,20),c(temp.acorr.nn1,temp.acorr.nn5,temp.acorr.nn10,temp.acorr.nn20),type="l",main="auto-correlation")

```

## Empirical Variogram
### Winter before 1970
```{r temp1970wvar, eval=TRUE, echo=FALSE, fig.height=2.5, fig.align="center"}
temp1970w.var1<-variogram(meansum~1,temp1970w,cutoff=1000,width=1)
temp1970w.var5<-variogram(meansum~1,temp1970w,cutoff=150,width=5)
temp1970w.var10<-variogram(meansum~1,temp1970w,cutoff=150,width=10)
temp1970w.var15<-variogram(meansum~1,temp1970w,cutoff=150,width=15)

grid.arrange(plot(temp1970w.var1, main="Bin width 1km"), 
             plot(temp1970w.var5, main="Bin width 5km"), ncol = 2)

grid.arrange(plot(temp1970w.var10, main="Bin width 10km"), 
             plot(temp1970w.var15, main="Bin width 15km"), ncol = 2)

bws<-data.frame(np=temp1970w.var1$np,bw=rep("1km",length(temp1970w.var1$np)))
bws<-rbind(bws,data.frame(np=temp1970w.var5$np,bw=rep("10km",length(temp1970w.var5$np))))
bws<-rbind(bws,data.frame(np=temp1970w.var10$np,bw=rep("20km",length(temp1970w.var10$np))))
bws<-rbind(bws,data.frame(np=temp1970w.var15$np,bw=rep("30km",length(temp1970w.var15$np))))

#plotting the numbers of points per bin and bandwidth as a boxplot
ggplot(bws, aes(x=bw, y=np, color=bw)) +
  geom_boxplot()
```

\newpage
### Summer before 1970
```{r temp1970svar, eval=TRUE, echo=FALSE, fig.height=2.5, fig.align="center"}
temp1970s.var1<-variogram(meansum~1,temp1970s,cutoff=1000,width=1)
temp1970s.var5<-variogram(meansum~1,temp1970s,cutoff=150,width=5)
temp1970s.var10<-variogram(meansum~1,temp1970s,cutoff=150,width=10)
temp1970s.var15<-variogram(meansum~1,temp1970s,cutoff=150,width=15)

grid.arrange(plot(temp1970s.var1, main="Bin width 1km"), 
             plot(temp1970s.var5, main="Bin width 5km"), ncol = 2)

grid.arrange(plot(temp1970s.var10, main="Bin width 10km"), 
             plot(temp1970s.var15, main="Bin width 15km"), ncol = 2)

bws<-data.frame(np=temp1970s.var1$np,bw=rep("1km",length(temp1970s.var1$np)))
bws<-rbind(bws,data.frame(np=temp1970s.var5$np,bw=rep("10km",length(temp1970s.var5$np))))
bws<-rbind(bws,data.frame(np=temp1970s.var10$np,bw=rep("20km",length(temp1970s.var10$np))))
bws<-rbind(bws,data.frame(np=temp1970s.var15$np,bw=rep("30km",length(temp1970s.var15$np))))

#plotting the numbers of points per bin and bandwidth as a boxplot
ggplot(bws, aes(x=bw, y=np, color=bw)) +
  geom_boxplot()
```

\newpage
### Winter before 2010
```{r temp2010wvar, eval=TRUE, echo=FALSE, fig.height=2.5, fig.align="center"}
temp2010w.var1<-variogram(meansum~1,temp2010w,cutoff=1000,width=1)
temp2010w.var5<-variogram(meansum~1,temp2010w,cutoff=150,width=5)
temp2010w.var10<-variogram(meansum~1,temp2010w,cutoff=150,width=10)
temp2010w.var15<-variogram(meansum~1,temp2010w,cutoff=150,width=15)

grid.arrange(plot(temp2010w.var1, main="Bin width 1km"), 
             plot(temp2010w.var5, main="Bin width 5km"), ncol = 2)

grid.arrange(plot(temp2010w.var10, main="Bin width 10km"), 
             plot(temp2010w.var15, main="Bin width 15km"), ncol = 2)

bws<-data.frame(np=temp2010w.var1$np,bw=rep("1km",length(temp2010w.var1$np)))
bws<-rbind(bws,data.frame(np=temp2010w.var5$np,bw=rep("10km",length(temp2010w.var5$np))))
bws<-rbind(bws,data.frame(np=temp2010w.var10$np,bw=rep("20km",length(temp2010w.var10$np))))
bws<-rbind(bws,data.frame(np=temp2010w.var15$np,bw=rep("30km",length(temp2010w.var15$np))))

#plotting the numbers of points per bin and bandwidth as a boxplot
ggplot(bws, aes(x=bw, y=np, color=bw)) +
  geom_boxplot()
```

\newpage
### Summer before 2010
```{r temp2010svar, eval=TRUE, echo=FALSE, fig.height=2.5, fig.align="center"}
temp2010s.var1<-variogram(meansum~1,temp2010s,cutoff=1000,width=1)
temp2010s.var5<-variogram(meansum~1,temp2010s,cutoff=150,width=5)
temp2010s.var10<-variogram(meansum~1,temp2010s,cutoff=150,width=10)
temp2010s.var15<-variogram(meansum~1,temp2010s,cutoff=150,width=15)

grid.arrange(plot(temp2010s.var1, main="Bin width 1km"), 
             plot(temp2010s.var5, main="Bin width 5km"), ncol = 2)

grid.arrange(plot(temp2010s.var10, main="Bin width 10km"), 
             plot(temp2010s.var15, main="Bin width 15km"), ncol = 2)

bws<-data.frame(np=temp2010s.var1$np,bw=rep("1km",length(temp2010s.var1$np)))
bws<-rbind(bws,data.frame(np=temp2010s.var5$np,bw=rep("10km",length(temp2010s.var5$np))))
bws<-rbind(bws,data.frame(np=temp2010s.var10$np,bw=rep("20km",length(temp2010s.var10$np))))
bws<-rbind(bws,data.frame(np=temp2010s.var15$np,bw=rep("30km",length(temp2010s.var15$np))))

#plotting the numbers of points per bin and bandwidth as a boxplot
ggplot(bws, aes(x=bw, y=np, color=bw)) +
  geom_boxplot()
```

## Fitted Semivariogram
### Winter before 1970
```{r temp1970wfit, eval=TRUE, echo=FALSE, fig.height=2.5, fig.align="center"}
temp1970w.var10<-variogram(meansum~1,temp1970w,cutoff=150,width=10)

models <- c("Exp", "Sph", "Gau", "Mat")
temp1970w.var10.fits <- lapply(X=1:4, FUN=function(x) fit.variogram(temp1970w.var10, model=vgm(models[x])))

grid.arrange(plot(temp1970w.var10, model=temp1970w.var10.fits[[1]], main = "Exponential: 10km"), 
             plot(temp1970w.var10, model=temp1970w.var10.fits[[2]], main = "Spherical: 10km"), ncol = 2)
grid.arrange(plot(temp1970w.var10, model=temp1970w.var10.fits[[3]], main = "Gaussian: 10km"), 
             plot(temp1970w.var10, model=temp1970w.var10.fits[[4]], main = "Mat: 10km"), ncol = 2)
```

\newpage
### Summer before 1970
```{r temp1970sfit, eval=TRUE, echo=FALSE, fig.height=2.5, fig.align="center"}
temp1970s.var10<-variogram(meansum~1,temp1970s,cutoff=150,width=10)

models <- c("Exp", "Sph", "Gau", "Mat")
temp1970s.var10.fits <- lapply(X=1:4, FUN=function(x) fit.variogram(temp1970s.var10, model=vgm(models[x])))

grid.arrange(plot(temp1970s.var10, model=temp1970s.var10.fits[[1]], main = "Exponential: 10km"), 
             plot(temp1970s.var10, model=temp1970s.var10.fits[[2]], main = "Spherical: 10km"), ncol = 2)
grid.arrange(plot(temp1970s.var10, model=temp1970s.var10.fits[[3]], main = "Gaussian: 10km"), 
             plot(temp1970s.var10, model=temp1970s.var10.fits[[4]], main = "Mat: 10km"), ncol = 2)
```

\newpage
### Winter after 1990
```{r temp2010wfit, eval=TRUE, echo=FALSE, fig.height=2.5, fig.align="center"}
temp2010w.var10<-variogram(meansum~1,temp2010w,cutoff=150,width=10)

models <- c("Exp", "Sph", "Gau", "Mat")
temp2010w.var10.fits <- lapply(X=1:4, FUN=function(x) fit.variogram(temp2010w.var10, model=vgm(models[x])))

grid.arrange(plot(temp2010w.var10, model=temp2010w.var10.fits[[1]], main = "Exponential: 10km"), 
             plot(temp2010w.var10, model=temp2010w.var10.fits[[2]], main = "Spherical: 10km"), ncol = 2)
grid.arrange(plot(temp2010w.var10, model=temp2010w.var10.fits[[3]], main = "Gaussian: 10km"), 
             plot(temp2010w.var10, model=temp2010w.var10.fits[[4]], main = "Mat: 10km"), ncol = 2)
```

\newpage
### Summer after 1990
```{r temp2010sfit, eval=TRUE, echo=FALSE, fig.height=2.5, fig.align="center"}
temp2010s.var10<-variogram(meansum~1,temp2010s,cutoff=150,width=10)

models <- c("Exp", "Sph", "Gau", "Mat")
temp2010s.var10.fits <- lapply(X=1:4, FUN=function(x) fit.variogram(temp2010s.var10, model=vgm(models[x])))

grid.arrange(plot(temp2010s.var10, model=temp2010s.var10.fits[[1]], main = "Exponential: 10km"), 
             plot(temp2010s.var10, model=temp2010s.var10.fits[[2]], main = "Spherical: 10km"), ncol = 2)
grid.arrange(plot(temp2010s.var10, model=temp2010s.var10.fits[[3]], main = "Gaussian: 10km"), 
             plot(temp2010s.var10, model=temp2010s.var10.fits[[4]], main = "Mat: 10km"), ncol = 2)
```

\newpage
## Ordinary krigin cross-validation
### Winter before 1970
```{r temp1970wOK, eval=TRUE, echo=FALSE, fig.height=3, fig.align="center"}
# # LOOCV is applied to each of the above fitted variograms, by iterating through the list of variograms
# # in each interation only the RMSE value and the index are stored (and only if better than previous iterations)
# RMSE <- 9999999
# temp1970w.best.m.index <- NULL
# for(i in 1:length(temp1970w.var10.fits)){
#   ok.cv.temp <- krige.cv(meansum~1, temp1970w, nfold=nrow(temp1970w), model = temp1970w.var10.fits[[i]])
#   rmse.temp <- sqrt(mean(ok.cv.temp$residual^2))
#   if(RMSE > rmse.temp){
#     RMSE <- rmse.temp
#     temp1970w.best.m.index <- i
#   }
# }
# 
# # Best fitted variogram (index number as added to the list above):
# temp1970w.best.m.index
# 
temp1970w.best.m.index <- 3
temp1970w.best.m.index
temp1970w.var10.fits[[temp1970w.best.m.index]]

# Ordinary Krigin
temp1970w.ok <- krige(meansum~1, temp1970w, grid, model = temp1970w.var10.fits[[temp1970w.best.m.index]])

# For better mapping, using leaflet, we convert the interpolated spdf into a raster
# with layer=1 and 2 we refer to the first and second attribute stored in the spdf
# the first attribut is the prediction the second represents the prediction uncertainty, 
# called variance.
gridded(temp1970w.ok)<-TRUE
temp1970w.ok.pred<-raster(temp1970w.ok, layer=1, values=TRUE)
temp1970w.ok.var<-raster(temp1970w.ok, layer=2, values=TRUE)

# Plotting
par(mfrow=c(1,2))
plot(temp1970w.ok.pred, main="Predicted temperature", col=rev(heat.colors(10)), breaks=seq(-50, 40, length.out = 10))
lines(oceans)
plot(temp1970w.ok.var, main="Prediction uncertainty (variance)", col=cm.colors(10), breaks=seq(0, 350, length.out = 10))
lines(oceans)
```

### Summer before 1970
```{r temp1970sOK, eval=TRUE, echo=FALSE, fig.height=3, fig.align="center"}
# # LOOCV is applied to each of the above fitted variograms, by iterating through the list of variograms
# # in each interation only the RMSE value and the index are stored (and only if better than previous iterations)
# RMSE <- 9999999
# temp1970s.best.m.index <- NULL
# for(i in 1:length(temp1970s.var10.fits)){
#   ok.cv.temp <- krige.cv(meansum~1, temp1970s, nfold=nrow(temp1970s), model = temp1970s.var10.fits[[i]])
#   rmse.temp <- sqrt(mean(ok.cv.temp$residual^2))
#   if(RMSE > rmse.temp){
#     RMSE <- rmse.temp
#     temp1970s.best.m.index <- i
#   }
# }
# 
# # Best fitted variogram (index number as added to the list above):
# temp1970s.best.m.index
# 
temp1970s.best.m.index <- 3
temp1970s.best.m.index
temp1970s.var10.fits[[temp1970s.best.m.index]]

# Ordinary Krigin
temp1970s.ok <- krige(meansum~1, temp1970s, grid, model = temp1970s.var10.fits[[temp1970s.best.m.index]])

# For better mapping, using leaflet, we convert the interpolated spdf into a raster
# with layer=1 and 2 we refer to the first and second attribute stored in the spdf
# the first attribut is the prediction the second represents the prediction uncertainty, 
# called variance.
gridded(temp1970s.ok)<-TRUE
temp1970s.ok.pred<-raster(temp1970s.ok, layer=1, values=TRUE)
temp1970s.ok.var<-raster(temp1970s.ok, layer=2, values=TRUE)

# Plotting
par(mfrow=c(1,2))
plot(temp1970s.ok.pred, main="Predicted temperature", col=rev(heat.colors(10)), breaks=seq(-50, 40, length.out = 10))
lines(oceans)
plot(temp1970s.ok.var, main="Prediction uncertainty (variance)", col=cm.colors(10), breaks=seq(0, 350, length.out = 10))
lines(oceans)
```

### Winter after 1990
```{r temp2010wOK, eval=TRUE, echo=FALSE, fig.height=3, fig.align="center"}
# # LOOCV is applied to each of the above fitted variograms, by iterating through the list of variograms
# # in each interation only the RMSE value and the index are stored (and only if better than previous iterations)
# RMSE <- 9999999
# temp2010w.best.m.index <- NULL
# for(i in 1:length(temp2010w.var10.fits)){
#   ok.cv.temp <- krige.cv(meansum~1, temp2010w, nfold=nrow(temp2010w), model = temp2010w.var10.fits[[i]])
#   rmse.temp <- sqrt(mean(ok.cv.temp$residual^2))
#   if(RMSE > rmse.temp){
#     RMSE <- rmse.temp
#     temp2010w.best.m.index <- i
#   }
# }
# 
# # Best fitted variogram (index number as added to the list above):
# temp2010w.best.m.index
# 
temp2010w.best.m.index <- 3
temp2010w.best.m.index
temp2010w.var10.fits[[temp2010w.best.m.index]]

# Ordinary Krigin
temp2010w.ok <- krige(meansum~1, temp2010w, grid, model = temp2010w.var10.fits[[temp2010w.best.m.index]])

# For better mapping, using leaflet, we convert the interpolated spdf into a raster
# with layer=1 and 2 we refer to the first and second attribute stored in the spdf
# the first attribut is the prediction the second represents the prediction uncertainty, 
# called variance.
gridded(temp2010w.ok)<-TRUE
temp2010w.ok.pred<-raster(temp2010w.ok, layer=1, values=TRUE)
temp2010w.ok.var<-raster(temp2010w.ok, layer=2, values=TRUE)

# Plotting
par(mfrow=c(1,2))
plot(temp2010w.ok.pred, main="Predicted temperature", col=rev(heat.colors(10)), breaks=seq(-50, 40, length.out = 10))
lines(oceans)
plot(temp2010w.ok.var, main="Prediction uncertainty (variance)", col=cm.colors(10), breaks=seq(0, 350, length.out = 10))
lines(oceans)
```

### Summer after 1990
```{r temp2010sOK, eval=TRUE, echo=FALSE, fig.height=3, fig.align="center"}
# # LOOCV is applied to each of the above fitted variograms, by iterating through the list of variograms
# # in each interation only the RMSE value and the index are stored (and only if better than previous iterations)
# RMSE <- 9999999
# temp2010s.best.m.index <- NULL
# for(i in 1:length(temp2010s.var10.fits)){
#   ok.cv.temp <- krige.cv(meansum~1, temp2010s, nfold=nrow(temp2010s), model = temp2010s.var10.fits[[i]])
#   rmse.temp <- sqrt(mean(ok.cv.temp$residual^2))
#   if(RMSE > rmse.temp){
#     RMSE <- rmse.temp
#     temp2010s.best.m.index <- i
#   }
# }
# 
# # Best fitted variogram (index number as added to the list above):
# temp2010s.best.m.index
# 
temp2010s.best.m.index <- 3
temp2010s.best.m.index
temp2010s.var10.fits[[temp2010s.best.m.index]]

# Ordinary Krigin
temp2010s.ok <- krige(meansum~1, temp2010s, grid, model = temp2010s.var10.fits[[temp2010s.best.m.index]])

# For better mapping, using leaflet, we convert the interpolated spdf into a raster
# with layer=1 and 2 we refer to the first and second attribute stored in the spdf
# the first attribut is the prediction the second represents the prediction uncertainty, 
# called variance.
gridded(temp2010s.ok)<-TRUE
temp2010s.ok.pred<-raster(temp2010s.ok, layer=1, values=TRUE)
temp2010s.ok.var<-raster(temp2010s.ok, layer=2, values=TRUE)

# Plotting
par(mfrow=c(1,2))
plot(temp2010s.ok.pred, main="Predicted temperature", col=rev(heat.colors(10)), breaks=seq(-50, 40, length.out = 10))
lines(oceans)
plot(temp2010s.ok.var, main="Prediction uncertainty (variance)", col=cm.colors(10), breaks=seq(0, 350, length.out = 10))
lines(oceans)
```

## Universal ordinary Krigin
### Continentality: Create distance to ocean layer
```{r continentality, eval=TRUE, echo=FALSE, fig.align="center"}
# Load highres coastlines for distance layer
oceans.50m <- readOGR(dsn="data", "ne_50m_ocean", verbose=F)
# Simplify geometry
oceans.simply <-SpatialPolygonsDataFrame(
  gSimplify(oceans.50m, tol=1, topologyPreserve=TRUE),
  data=oceans.50m@data)

# Build blank raster
r <- raster(DEM)
r <- setValues(r, 0)
r <- aggregate(r, fact=10)

# Make values NA where polygon intesects raster
r <- mask(r, oceans.simply)

# Run distance check
ocean.dist <- distance(r)

# # to restrict your search
# searchLimit <- 100 # the maximum distance in raster units from lakes/boundaries
# oceans.simply.buff <- gBuffer(oceans.simply, width = searchLimit, byid = T)
# rB <- crop(r, extent(oceans.simply.buff))
# 
# # much faster...
# rDB <- distance(rB)

levelplot(ocean.dist) + layer(sp.polygons(oceans, fill='lightblue', alpha=0.3))
```

### Sun incidence angle
```{r h}
# Create latitude and longitude layers
lon <- lat <- raster(DEM)
lon[] <- coordinates(raster(DEM))[, 1]
lat[] <- coordinates(raster(DEM))[, 2]

# Slope and aspect
slope <- terrain(landDEM, opt='slope', unit='radians')
aspect <- terrain(landDEM, opt='aspect', unit='radians')

# Split the hemispheres
split.hemi <- setValues(lat, 1)
split.hemi[1:(nrow(lat)/2), 1:ncol(lat)] <- -1

# Calculate the gradient in latitude direction
latGrad <- (cos(aspect)*slope)*180/pi
latGrad <- latGrad*split.hemi
levelplot(latGrad, main="Latitude gradient, hemisphere corrected") + layer(sp.polygons(oceans, fill='blue', alpha=0.7))

## Solar incident angle (height at midday)
# http://www.geoastro.de/astro/mittag/index.htm; h = 90° - β + δ
# Substract ghradient northern hemisphere and add to the southern
# 21.6 - "Summer"; +23.5°
h.w <- 90-abs(lat + 23.5)+latGrad
h.s <- 90-abs(lat - 23.5)+latGrad

levelplot(h.w, main="Sun incident angle, winter") + layer(sp.polygons(oceans, fill='blue', alpha=0.7))
levelplot(h.s, main="Sun incident angle, summer") + layer(sp.polygons(oceans, fill='blue', alpha=0.7))
```


### Winter before 1970
```{r temp1970wUOK, eval=TRUE, echo=FALSE, fig.height=3, fig.align="center"}
# Extract continentality and elevation at measurement points from rasters
temp1970w$elev <- extract(raster(DEM), temp1970w)
temp1970w$cont <- extract(ocean.dist, temp1970w)
temp1970w$h <- extract(h.w, temp1970w)

# Linear Regression
temp1970w.lm.test <- lm(meansum~elev+cont+h+s+a, data=temp1970w@data)
summary(temp1970w.lm.test)
```
### Summer before 1970
### Winter after 1990
### Summer after 1990


## Ordinary Krigin
### Winter before 1970
### Summer before 1970
### Winter after 1990
### Summer after 1990

